tags: TLS, CA, x509

# 02. 创建 CA 根证书和秘钥

<!-- TOC -->

- [02. 创建 CA 根证书和秘钥](#02-创建-ca-根证书和秘钥)
    - [安装 cfssl 工具集](#安装-cfssl-工具集)
    - [创建配置文件](#创建配置文件)
    - [创建证书签名请求文件](#创建证书签名请求文件)
    - [生成 CA 证书和私钥](#生成-ca-证书和私钥)
    - [分发证书文件](#分发证书文件)
    - [参考](#参考)

<!-- /TOC -->

为确保安全，`kubernetes` 系统各组件需要使用 `x509` 证书对通信进行加密和认证。

CA (Certificate Authority) 是自签名的根证书，用来签名后续创建的其它证书。

CA 证书是集群所有节点共享的，**只需要创建一次**，后续用它签名其它所有证书。

本文档使用 `CloudFlare` 的 PKI 工具集 [cfssl](https://github.com/cloudflare/cfssl) 创建所有证书。

注意：如果没有特殊指明，本文档的所有操作**均在 master137 节点上执行**。

## 安装 cfssl 工具集

``` bash

sudo mkdir -p /opt/k8s/cert && cd /opt/k8s/work

wget https://github.com/cloudflare/cfssl/releases/download/v1.4.1/cfssl_1.4.1_linux_amd64
mv cfssl_1.4.1_linux_amd64 /opt/k8s/bin/cfssl

wget https://github.com/cloudflare/cfssl/releases/download/v1.4.1/cfssljson_1.4.1_linux_amd64
mv cfssljson_1.4.1_linux_amd64 /opt/k8s/bin/cfssljson

wget https://github.com/cloudflare/cfssl/releases/download/v1.4.1/cfssl-certinfo_1.4.1_linux_amd64
mv cfssl-certinfo_1.4.1_linux_amd64 /opt/k8s/bin/cfssl-certinfo

chmod +x /opt/k8s/bin/*
export PATH=/opt/k8s/bin:$PATH
```

## 创建配置文件

CA 配置文件用于配置根证书的使用场景 (profile) 和具体参数 (usage，过期时间、服务端认证、客户端认证、加密等)：

``` bash
cd /opt/k8s/work
cat > ca-config.json <<EOF
{
  "signing": {
    "default": {
      "expiry": "87600h"
    },
    "profiles": {
      "kubernetes": {
        "usages": [
            "signing",
            "key encipherment",
            "server auth",
            "client auth"
        ],
        "expiry": "876000h"
      }
    }
  }
}
EOF
```
+ `signing`：表示该证书可用于签名其它证书（生成的 `ca.pem` 证书中 `CA=TRUE`）；
+ `server auth`：表示 client 可以用该该证书对 server 提供的证书进行验证；
+ `client auth`：表示 server 可以用该该证书对 client 提供的证书进行验证；
+ `"expiry": "876000h"`：证书有效期设置为 100 年；

## 创建证书签名请求文件

``` bash
cd /opt/k8s/work
cat > ca-csr.json <<EOF
{
  "CN": "kubernetes-ca",
  "key": {
    "algo": "rsa",
    "size": 2048
  },
  "names": [
    {
      "C": "CN",
      "ST": "BeiJing",
      "L": "BeiJing",
      "O": "k8s",
      "OU": "opsnull"
    }
  ],
  "ca": {
    "expiry": "876000h"
 }
}
EOF
```
+ `CN：Common Name`：kube-apiserver 从证书中提取该字段作为请求的**用户名 (User Name)**，浏览器使用该字段验证网站是否合法；
+ `O：Organization`：kube-apiserver 从证书中提取该字段作为请求用户所属的**组 (Group)**；
+ kube-apiserver 将提取的 `User、Group` 作为 `RBAC` 授权的用户标识；

注意：
1. 不同证书 csr 文件的 CN、C、ST、L、O、OU 组合必须不同，否则可能出现 `PEER'S CERTIFICATE HAS AN INVALID SIGNATURE` 错误；
2. 后续创建证书的 csr 文件时，CN 都不相同（C、ST、L、O、OU 相同），以达到区分的目的；

## 生成 CA 证书和私钥

``` bash
cd /opt/k8s/work
cfssl gencert -initca ca-csr.json | cfssljson -bare ca
ls ca*
```

## 分发证书文件

``` bash
#在/opt/k8s/work编写sh文件 ca_cert_dispatcher.sh
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${NODE_IPS[@]}
  do
    echo ">>> ${node_ip}"
    ssh root@${node_ip} "mkdir -p /etc/kubernetes/cert"
    scp /opt/k8s/work/ca*.pem /opt/k8s/work/ca-config.json root@${node_ip}:/etc/kubernetes/cert
  done
```

## 参考

1. [各种 CA 证书类型](https://github.com/kubernetes-incubator/apiserver-builder/blob/master/docs/concepts/auth.md)

## HTTPS流程

这里复习一下HTTPS的流程

### 服务器证书申请

1. 在服务器上生成CSR文件（证书申请文件，内容包括证书公钥、使用的Hash算法、申请的域名、公司名称、职位等信息）

2. 把CSR文件和其他可能的证件上传到**CA认证机构**，CA机构收到证书申请之后，使用申请中的Hash算法，对部分内容进行**摘要**，然后使用**CA机构自己的私钥**对这段摘要信息**进行签名**

3. 然后CA机构把签名过的证书通过邮件形式发送到申请者手中。

4. 申请者收到证书之后部署到自己的web服务器中

对于上文的部署，因为CA是我们自己生成的，所以需要把CA预置到各个节点，这样各节点才能够通过预置的CA证书，做服务器证书验签

### HTTPS交互

1. client Hello,客户端（通常是浏览器）先向服务器发出**加密通信的请求**，内容包括
```

    （1） 支持的协议版本，比如TLS 1.0版。
    （2） 一个客户端生成的随机数 random1，稍后用于生成"对话密钥"。
    （3） 支持的加密方法，比如RSA公钥加密。
    （4） 支持的压缩方法。
```
2. 服务器收到请求,然后响应 (server Hello)，主要是**返回证书**
```
    （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
    （2） 一个服务器生成的随机数random2，稍后用于生成"对话密钥"。
    （3） 确认使用的加密方法，比如RSA公钥加密。
    （4） 服务器证书。
```
3. 客户端收到证书之后会首先会**进行验证**
```
    （1） 如果证书中的签名算法为sha256RSA，说明CA机构使用sha256对证书进行摘要。
    （2） 然后使用RSA算法对摘要进行私钥签名。具体为，client端使用CA的公钥（CA已经预置在系统中）对服务器的证书进行验签。
    （3） CA公钥解密后得了sha256的证书摘要，然后client再使用sha256对证书内容进行一次摘要，如果得到的值和验签之后得到的摘要值相同，则表示证书没有被修改过。
```
4. 验证通过后，客户端生成一个**随机数pre-master secret**（用于生成对称秘钥），然后使用**服务器证书的公钥**进行加密，然后传递给服务器端。
```
PreMaster Secret是在客户端使用RSA或者Diffie-Hellman等加密算法生成的。它将用来跟服务端和客户端在Hello阶段产生的随机数结合在一起生成 Master Secret。在客户端使用服务端的公钥对PreMaster Secret进行加密之后传送给服务端，服务端将使用私钥进行解密得到PreMaster secret。也就是说服务端和客户端都有一份相同的PreMaster secret和随机数。
```
5. 服务器收到使用公钥加密的内容，在**服务器端使用私钥解密**之后获得随机数pre-master secret，然后根据radom1、radom2、pre-master secret通过一定的算法得出**session Key和MAC算法秘钥**，作为后面交互过程中使用对称秘钥。同时客户端也会使用radom1、radom2、pre-master secret，和同样的算法生成session Key和MAC算法的秘钥。

6. 然后再后续的交互中就使用session Key和MAC算法的秘钥对传输的内容进行加密和解密。
```
具体的步骤是先使用MAC秘钥对内容进行摘要，然后把摘要放在内容的后面使用sessionKey再进行加密。对于客户端发送的数据，服务器端收到之后，需要先使用client_write_key进行解密，然后使用client_write_MAC_key对数据完整性进行验证。服务器端发送的数据，客户端会使用server_write_key和server_write_MAC_key进行相同的操作。
```
参考 https://www.jianshu.com/p/b0b6b88fe9fe

以上为单向的**服务端证书**通信流程，**客户端证书**同理，亦同理于**双向证书认证**
